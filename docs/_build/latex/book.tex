%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{booktabs}{sphinx}
\PassOptionsToPackage{colorrows}{sphinx}

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}


\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{Unity-based Simulation of Active Transport in Built Environment}
\date{Oct 15, 2025}
\release{}
\author{Dimitrios Dimitriadis, Thodoris Gounelas}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\begin{titlepage}
  \centering
  \vspace*{1cm}
  \includegraphics[width=0.18\textwidth]{unilogo.png}\\[1.5cm]
  {\fontsize{18}{22}\selectfont\textbf{ΠΑΝΕΠΙΣΤΗΜΙΟ ΘΕΣΣΑΛΙΑΣ}\\[0.5em]}
  {\large Σχολή Τεχνολογίας \\[0.5em] Τμήμα Ψηφιακών Συστημάτων \\[2em]}
  {\fontsize{24}{28}\selectfont\textbf{Τίτλος Πτυχιακής}\\[2em]}
  {\large \textbf{ΠΤΥΧΙΑΚΗ ΕΡΓΑΣΙΑ} \\[1.5em]}
  {\large Ονοματεπώνυμο (AM: ?) \\[1.5em]}
  {\large Επιβλέπων: ονομ/μο, βαθμίδα \\[2em]}
  {\large \today\par}
  \vfill
\end{titlepage}
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{Thesis::doc}}


\sphinxAtStartPar
\sphinxstyleemphasis{Προσομοίωση Ενεργής Μετακίνησης σε Δομημένο Περιβάλλον με την Χρήση Unity}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\Large Internal Links}
\end{DUlineblock}

\sphinxAtStartPar
{[}{[}1. Introduction{]}{]}
{[}{[}2. Data Acquisition{]}{]}
{[}{[}3. Unity{]}{]}
{[}{[}3.1 Navmesh{]}{]}
{[}{[}3.2 Animations{]}{]}
Final Unity Import and Simulation

\sphinxAtStartPar
Note : Obsidian uses \sphinxhref{https://help.obsidian.md/Linking+notes+and+files/Internal+links}{Wikilink}

\sphinxAtStartPar
!{[}{[}1. Introduction{]}{]}

\sphinxAtStartPar
!{[}{[}2. Data Acquisition{]}{]}

\sphinxAtStartPar
!{[}{[}3. Unity{]}{]}

\begin{DUlineblock}{0em}
\item[] \sphinxstylestrong{\large References}
\end{DUlineblock}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxhref{https://csum.civ.uth.gr/active-mobility/}{Active Mobility webpage by CSUM}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.openstreetmap.org/copyright}{OpenStreetMap License}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.unity3d.com/ScriptReference/AI.NavMeshAgent.html}{Unity NavMeshAgent API Reference}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.unity3d.com/Packages/com.unity.ai.navigation@1.1/manual/NavMeshSurface.html}{Unity NavMeshSurface Component}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.unity3d.com/ScriptReference/AI.NavMeshObstacle.html}{Unity NavMeshObstacle API Reference}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.unity3d.com/ScriptReference/AI.NavMesh.SamplePosition.html}{Unity NavMesh.SamplePosition Documentation}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://docs.unity3d.com/ScriptReference/Animator.html}{Unity Animator API Reference}

\end{enumerate}

\sphinxstepscope


\chapter{Abstract}
\label{\detokenize{Abstact:abstract}}\label{\detokenize{Abstact::doc}}
\sphinxAtStartPar
Active mobility within urban environments has become increasingly crucial for public health and sustainable transportation systems. While significant efforts focus on infrastructure development—such as bicycle lanes and pedestrian pathways—research into mobility patterns and behavioral analysis remains essential for evidence\sphinxhyphen{}based urban planning. This thesis presents a comprehensive simulation application designed to facilitate research and visualization of active mobility scenarios in built environments. The application serves dual purposes: providing researchers with sophisticated analytical tools for conducting case studies, while maintaining accessibility for stakeholders with varying technical expertise. Through intuitive visualization and interactive demonstration capabilities, the platform enables effective communication of research findings and supports informed decision\sphinxhyphen{}making in urban mobility planning.


\section{Περίληψη}
\label{\detokenize{Abstact:id1}}
\sphinxAtStartPar
Η ενεργή κινητικότητα στα αστικά περιβάλλοντα έχει καταστεί ολοένα και πιο καθοριστική για τη δημόσια υγεία και τα βιώσιμα συστήματα μεταφοράς. Ενώ σημαντικές προσπάθειες εστιάζουν στην ανάπτυξη υποδομών—όπως ποδηλατόδρομοι και πεζόδρομοι—η έρευνα σχετικά με τα πρότυπα κινητικότητας και την ανάλυση συμπεριφοράς παραμένει ουσιώδης για τον τεκμηριωμένο αστικό σχεδιασμό. Η παρούσα διπλωματική εργασία παρουσιάζει μια ολοκληρωμένη εφαρμογή προσομοίωσης που σχεδιάστηκε για να διευκολύνει την έρευνα και την οπτικοποίηση σεναρίων ενεργής κινητικότητας σε δομημένα περιβάλλοντα. Η εφαρμογή εξυπηρετεί δυπλό σκοπό: παρέχει στους ερευνητές εξελιγμένα αναλυτικά εργαλεία για τη διεξαγωγή μελετών περίπτωσης, διατηρώντας παράλληλα την προσβασιμότητα για ενδιαφερόμενους με διαφορετικό επίπεδο τεχνικής εμπειρίας. Μέσω διαισθητικής οπτικοποίησης και διαδραστικών δυνατοτήτων επίδειξης, η πλατφόρμα επιτρέπει την αποτελεσματική επικοινωνία των ερευνητικών ευρημάτων και υποστηρίζει τη λήψη τεκμηριωμένων αποφάσεων στον σχεδιασμό αστικής κινητικότητας.

\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{Introduction:introduction}}\label{\detokenize{Introduction::doc}}

\section{Project Summary}
\label{\detokenize{Introduction:project-summary}}
\sphinxAtStartPar
This thesis focuses on the development of an \sphinxstylestrong{active movement simulation in a built environment} using the \sphinxstylestrong{cesium SDK, Unity, and Blender}. The project involves creating a \sphinxstylestrong{simplified 3D representation of a real environment} by integrating \sphinxstylestrong{geospatial data} from \sphinxstylestrong{google maps} retrieved via the \sphinxstylestrong{cesium SDK}. Through \sphinxstylestrong{Blender}, a modifiable bike model is created, allowing for the simulation of various bike designs based on specific measurements, along with a rider.


\section{Purpose}
\label{\detokenize{Introduction:purpose}}
\sphinxAtStartPar
The goal of this tool is to create a simulation that allows for the study of various cases by simulating different scenarios, providing insights into the dynamics of {\hyperref[\detokenize{glossary:active-mobility}]{\sphinxcrossref{\DUrole{std,std-ref}{active mobility}}}} in built environments, , enabling researchers and urban planners to analyze and optimize infrastructure for active mobility, fostering safer and more efficient urban environments.


\section{Pipeline}
\label{\detokenize{Introduction:pipeline}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{plan}.png}
\caption{Pipeline of project}\label{\detokenize{Introduction:id1}}\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Google 3D Maps}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Retrieve map data from Google 3D Maps for the target location.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cesium}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use Cesium to convert the map data into a 3D mesh compatible with Unity.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{YAML File}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Define bicycle properties (e.g., dimensions, measurements) in the YAML file to ensure accurate modeling in Blender.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Blender}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Creation of a modifiable 3D model of a bike and rider that will change based on the specifications provided in the YAML file.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Unity}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Integrate the 3D map from Cesium and the bicycle model from Blender into Unity.

\item {} 
\sphinxAtStartPar
Use Unity to simulate the environment and interactions.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Simulation}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Run the simulation in Unity to test and analyze movement mobility.

\end{itemize}

\end{enumerate}

\sphinxstepscope


\chapter{Pipeline}
\label{\detokenize{Pipeline:pipeline}}\label{\detokenize{Pipeline::doc}}
\sphinxAtStartPar
\sphinxincludegraphics{{plan}.png}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Google 3D Maps}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Retrieve map data from Google 3D Maps for the target location.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cesium}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Use Cesium to convert the map data into a 3D mesh compatible with Unity.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{YAML File}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Define bicycle properties (e.g., dimensions, material) in the YAML file to ensure accurate modeling in Blender.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Blender}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Import a bicycle 3D model and configure its properties based on the specifications provided in the YAML file.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Unity}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Integrate the 3D map from Cesium and the bicycle model from Blender into Unity.

\item {} 
\sphinxAtStartPar
Use Unity to simulate the environment and interactions.

\end{itemize}

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Simulation}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Run the simulation in Unity to test and analyze movement mobility.

\end{itemize}

\end{enumerate}

\sphinxstepscope


\chapter{3D Environment Setup}
\label{\detokenize{Cesium:d-environment-setup}}\label{\detokenize{Cesium::doc}}

\section{Cesium}
\label{\detokenize{Cesium:cesium}}
\sphinxAtStartPar
Cesium is an open platform for 3D geospatial data visualization. It allows developers to create highly accurate, real\sphinxhyphen{}world simulations using geographic data. Cesium provides tools for streaming, visualizing, and interacting with large\sphinxhyphen{}scale 3D geospatial datasets, such as terrain, building models, and map imagery, in a performant and dynamic way.

\sphinxAtStartPar
Key features of Cesium include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{3D Tiles}: An open standard for streaming massive 3D datasets efficiently.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Integration with Real\sphinxhyphen{}World Data}: It supports data from sources like Google 3D Maps, OpenStreetMap, and custom datasets.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cross\sphinxhyphen{}Platform Compatibility}: Cesium is accessible on web browsers, game engines like Unity, and standalone applications.

\end{itemize}

\sphinxAtStartPar
In this project, Cesium is used to convert 3D map data into a Unity\sphinxhyphen{}compatible format.


\section{Cesium unity package}
\label{\detokenize{Cesium:cesium-unity-package}}
\sphinxAtStartPar
To utilize real\sphinxhyphen{}world geospatial data in Unity, we rely on the \sphinxhref{https://cesium.com/platform/cesium-for-unity/}{\sphinxstylestrong{Cesium for Unity}} plugin. This plugin facilitates the seamless integration of 3D geospatial data into Unity, allowing for accurate environmental simulations.


\subsection{Cesium ion Assets}
\label{\detokenize{Cesium:cesium-ion-assets}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{cesium-ion-assets}.png}
\caption{Cesium terrain options}\label{\detokenize{Cesium:ion-assets}}\end{figure}

\sphinxAtStartPar
The Cesium ion Assets menu in Unity provides quick access to various geospatial data assets which we can use to generate a 3D mesh. Below are the options:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cesium OSM Buildings}:\\
Adds 3D building models sourced from OpenStreetMap, ideal for urban simulations or city planning.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Google Photorealistic 3D Tiles}:\\
Provides highly detailed 3D tilesets for photorealistic visualizations.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cesium World Terrain + Bing Maps Aerial imagery}:\\
Combines high\sphinxhyphen{}resolution terrain data with Bing Maps’ aerial imagery for realistic 3D landscapes.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cesium World Terrain + Bing Maps Aerial with Labels imagery}:\\
Similar to the above but includes labels (e.g., place names, roads) over the aerial imagery for better context.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cesium World Terrain + Bing Maps Road imagery}:\\
Displays terrain data with a road map overlay, useful for navigation\sphinxhyphen{}focused applications.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Cesium World Terrain + Sentinel\sphinxhyphen{}2 imagery}:\\
Uses satellite imagery from Sentinel\sphinxhyphen{}2, providing detailed and up\sphinxhyphen{}to\sphinxhyphen{}date Earth observation data.

\end{itemize}

\sphinxAtStartPar
For our specific purpose, we are utilizing the \sphinxstylestrong{Google Photorealistic 3D Tiles}. These tiles provide highly detailed, photorealistic 3D visualizations, making them ideal for creating immersive and accurate simulations of real\sphinxhyphen{}world environments.


\section{Cesium Georeference Object}
\label{\detokenize{Cesium:cesium-georeference-object}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{cesium-georeference}.png}
\caption{Cesium georeference options}\label{\detokenize{Cesium:cesium-georeference}}\end{figure}

\sphinxAtStartPar
The \sphinxstylestrong{Cesium Georeference} GameObject in Unity is responsible for aligning the 3D scene with real\sphinxhyphen{}world geospatial coordinates. It ensures that the virtual environment corresponds accurately to the Earth’s surface by defining the origin and scale of the scene. Key features include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Origin Mode}:\\
Allows you to set the placement of the origin, such as using a \sphinxstylestrong{Cartographic Origin} (latitude, longitude, and height) or an \sphinxstylestrong{Earth\sphinxhyphen{}Centered, Earth\sphinxhyphen{}Fixed (ECEF)} coordinate system.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Authority}:\\
Specifies the geospatial reference system, such as \sphinxstylestrong{Earth Centered Earth Fixed}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Origin (Longitude Latitude Height)}:\\
Lets you define the geographic location of the origin in terms of latitude, longitude, and height.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ECEF Coordinates}:\\
Displays the calculated Earth\sphinxhyphen{}Centered, Earth\sphinxhyphen{}Fixed (ECEF) coordinates for the origin.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Scale}:\\
Adjusts the scale of the scene, which can be useful for creating simulations at different levels of detail.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Ellipsoid Override}:\\
Allows you to override the default Cesium Ellipsoid if a custom ellipsoid is required for specific geospatial applications.

\end{itemize}


\section{3D\sphinxhyphen{}Mesh}
\label{\detokenize{Cesium:d-mesh}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{campus}.png}
\caption{Cesium georeference options}\label{\detokenize{Cesium:cesium-3d-generated-mesh}}\end{figure}

\sphinxAtStartPar
The \sphinxstylestrong{3D\sphinxhyphen{}Mesh} is a 3D model of a specific geographic area created using Cesium’s geospatial data. To generate the mesh we have to specify:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{A Terrain Provider}:\\
Choose a data source, such as \sphinxstylestrong{Google Photorealistic 3D Tiles} or \sphinxstylestrong{Cesium World Terrain}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{The Coordinates}:\\
Define the location (latitude, longitude, and height) for the area of interest.

\end{enumerate}

\sphinxAtStartPar
In this project, we generated a 3D\sphinxhyphen{}Mesh of the \sphinxstylestrong{Geopolis Campus} in Larisa, Greece.

\sphinxstepscope


\chapter{3D Models and Tools used}
\label{\detokenize{Blender:d-models-and-tools-used}}\label{\detokenize{Blender::doc}}

\section{Blender}
\label{\detokenize{Blender:blender}}
\sphinxAtStartPar
Blender is a free and open\sphinxhyphen{}source 3D creation suite that covers almost the entire 3D pipeline in a single program. It’s widely used by hobbyists, indie creators, and even professionals in film, game development, and design.


\section{Why Blender}
\label{\detokenize{Blender:why-blender}}
\sphinxAtStartPar
The reason Blender is used for this project is mainly because of its versatility, it can do everything that is needed for this project in the same environment, these things include:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Modeling:} The main frame of the bike as well as all parts of it like the seat and wheels will be different models that will contain several meshes that can be easily handled in Blender.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rigging:} In order for us to make the bike editable a basic rig will be needed and Blender makes that easy with it’s armature and bone items.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Coding:} Blender has a python compiler built in so everything code related that has to do with the bike will be done in Blender.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Animation:} Blender has an easy and effective video editing feature that allows for easy animations and rendering.

\end{itemize}

\sphinxstepscope


\section{Research}
\label{\detokenize{Research:research}}\label{\detokenize{Research::doc}}
\sphinxAtStartPar
To ensure accurate naming and placement of all components, a solid understanding of bicycle structure and geometry was required. This section summarizes the key research steps and sources used to inform the modeling process.


\subsection{1. Terminology: Anatomy and Geometry}
\label{\detokenize{Research:terminology-anatomy-and-geometry}}
\sphinxAtStartPar
The first step was to identify the correct terms for every part and measurement of the bike. This was accomplished using:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bike Lock WIKI:} A security\sphinxhyphen{}oriented review and recommendation site for bicycles, which provides a comprehensive \sphinxhref{https://www.bikelockwiki.com/parts-of-a-bike-diagram/}{diagram of bike parts}. The most important parts are shown below:

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Bike_Parts}.png}
\caption{Bike parts found in \sphinxhref{https://www.bikelockwiki.com}{bikelockwiki.com}}\label{\detokenize{Research:bike-parts}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{GeometryGeeks.bike:} For geometry, the site \sphinxhref{https://geometrygeeks.bike/understanding-bike-geometry/}{GeometryGeeks.bike} offers a clear reference image and thorough explanations of all relevant measurements.

\end{itemize}


\subsection{2. Prototype Reference}
\label{\detokenize{Research:prototype-reference}}
\sphinxAtStartPar
To create a base prototype for the bike, a temporary template was needed. This was sourced from a \sphinxhref{https://www.researchgate.net/publication/295675697\_Multi-objective\_optimization\_of\_an\_on-road\_bicycle\_frame\_by\_uniform\_design\_and\_compromise\_programming}{research paper} on bicycle frame optimization. The example image below, taken from the paper, provided reference values for the length and thickness of each bike part:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Bike_Reference}.png}
\caption{Image taken from the \sphinxhref{https://www.researchgate.net/figure/Basic-dimensions-of-on-road-bicycle-frame-model\_fig2\_295675697}{research paper}}\label{\detokenize{Research:bike-reference}}\end{figure}


\subsection{3. Identifying Key Measurements}
\label{\detokenize{Research:identifying-key-measurements}}
\sphinxAtStartPar
To enable customization, it was necessary to determine which measurements should be editable. Research into Blender’s capabilities and the most vital parts of the bike led to the following list of essential data:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Seat Angle

\item {} 
\sphinxAtStartPar
Seat Post

\item {} 
\sphinxAtStartPar
Seat Tube C\sphinxhyphen{}C

\item {} 
\sphinxAtStartPar
Stack

\item {} 
\sphinxAtStartPar
Reach

\item {} 
\sphinxAtStartPar
Head Angle

\item {} 
\sphinxAtStartPar
Head Tube

\item {} 
\sphinxAtStartPar
Handlebar Height

\item {} 
\sphinxAtStartPar
Fork Length

\item {} 
\sphinxAtStartPar
Rake/Offset

\item {} 
\sphinxAtStartPar
Wheelbase

\end{enumerate}

\sphinxAtStartPar
More information on how these are used can be found in the {[}{[}Setting the Rig{]}{]} section.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Bike_Geometry}.png}
\caption{Bike geometry found in \sphinxhref{https://geometrygeeks.bike}{geometrygeeks.bike}}\label{\detokenize{Research:bike-geometry}}\end{figure}


\subsection{4. Data Collection}
\label{\detokenize{Research:data-collection}}
\sphinxAtStartPar
A single prototype is not sufficient to ensure the model’s flexibility. Therefore, several examples were gathered from \sphinxhref{https://geometrygeeks.bike/}{geometrygeeks.bike} and its database of bikes and measurements. This allowed for a broader understanding of the range of possible geometries and ensured the model could accommodate various designs.

\sphinxstepscope


\section{Making the Model}
\label{\detokenize{Making the Model:making-the-model}}\label{\detokenize{Making the Model::doc}}
\sphinxAtStartPar
This section describes the step\sphinxhyphen{}by\sphinxhyphen{}step process of constructing the 3D bike model, from the initial frame to the final assembly of all components.


\subsection{1. Building the Frame}
\label{\detokenize{Making the Model:building-the-frame}}
\sphinxAtStartPar
To begin, a simple prototype bike frame was created using cylinders, each representing one of the six main parts of the frame. These were aligned and measured by tracing over the example from the research paper referenced in the {\hyperref[\detokenize{Research::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{Research}}}} section.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Modeling}.png}
\caption{Screenshot taken in Blender}\label{\detokenize{Making the Model:modeling}}\end{figure}

\sphinxAtStartPar
After establishing the standard frame, the Seat Stays and Chain Stays were split to accommodate the rear wheel, completing the frame structure. The fork was then created and split to hold the front wheel. With these elements in place, the wheels, seat, and handlebars were added, resulting in a simple but complete model ready for rigging.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Modeling_Final}.png}
\caption{Screenshot taken in Blender}\label{\detokenize{Making the Model:modeling-final}}\end{figure}


\subsection{2. Modeling the Wheels}
\label{\detokenize{Making the Model:modeling-the-wheels}}
\sphinxAtStartPar
The wheels were modeled early in the process, as they do not interfere with the frame design and can be added independently. The “Wireframe” modifier was used for the spokes to avoid creating a mesh for each one, and the spokes were separated into left and right to achieve the typical curvature. A simple rim and tire were then added. Each wheel also includes a hidden mesh (SizeF for the front, SizeB for the back) to control scaling in scripts.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Wheel}.png}
\caption{Screenshot taken in Blender}\label{\detokenize{Making the Model:wheel}}\end{figure}


\subsection{3. Drivetrain Components}
\label{\detokenize{Making the Model:drivetrain-components}}
\sphinxAtStartPar
To ensure the pedals functioned as intended, each pedal was split into four parts: a spacer (for left/right positioning), the pedal arm, a mesh to hold the pedal on the arm (short cylinder at the lower end), and the pedal itself. The importance of these extra parts is discussed further in the {\hyperref[\detokenize{Setting the Rig::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{Setting the Rig}}}} section.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Pedal}.png}
\caption{Screenshot taken in Blender}\label{\detokenize{Making the Model:pedal}}\end{figure}

\sphinxAtStartPar
Due to their complexity, the chain was divided into four stationary pieces (left, right, top, and down), as shown below. The chain does not function mechanically but visually completes the drivetrain.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Chain}.png}
\caption{Screenshot taken in Blender}\label{\detokenize{Making the Model:chain}}\end{figure}


\subsection{4. Final Assembly and Refinements}
\label{\detokenize{Making the Model:final-assembly-and-refinements}}
\sphinxAtStartPar
With all major parts complete, minor refinements were made: adding the rake to prevent the wheel from floating (due to the fork’s lack of curvature), including the crankset and cassette, and improving the saddle’s appearance. The final result is a complete bike model, ready to be transformed according to the data.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Model}.png}
\caption{Screenshot taken in Blender}\label{\detokenize{Making the Model:model}}\end{figure}

\sphinxstepscope


\section{Rig Explanation}
\label{\detokenize{Setting the Rig:rig-explanation}}\label{\detokenize{Setting the Rig::doc}}
\sphinxAtStartPar
To transform the bike into the desired measurements, a system was needed to interpret these values and apply them effectively. The final system used “key points”, by placing these points at the locations where the most important parts of the bike begin or end, the model can take shape and fill in the gaps, as explained below.

\sphinxAtStartPar
The key points where condensed into 5 points in the 3D environment, for simplicity the Y axis will be 0 and any action will be done in the Z and X axes, the height and length of the bike respectively:


\subsection{Key Points and Their Coordinates}
\label{\detokenize{Setting the Rig:key-points-and-their-coordinates}}

\subsubsection{A: Bottom Bracket (BB) Point}
\label{\detokenize{Setting the Rig:a-bottom-bracket-bb-point}}
\sphinxAtStartPar
The origin of the bike’s geometry, where the crank axle sits:
\begin{equation*}
\begin{split}
\begin{aligned}
A_x &= 0 \\
A_z &= 0
\end{aligned}
\end{split}
\end{equation*}

\subsubsection{B: End of Seat Tube (C\sphinxhyphen{}C Measurement)}
\label{\detokenize{Setting the Rig:b-end-of-seat-tube-c-c-measurement}}
\sphinxAtStartPar
Calculated from the BB using the seat tube length and seat angle:
\begin{equation*}
\begin{split}
\begin{aligned}
B_x &= -\cos(\theta_{seat}) \cdot L_{seat} \\
B_z &= \sin(\theta_{seat}) \cdot L_{seat}
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\theta_{seat}\) is the seat tube angle, \(L_{seat}\) is the seat tube length.


\subsubsection{C: Top of the Head Tube}
\label{\detokenize{Setting the Rig:c-top-of-the-head-tube}}
\sphinxAtStartPar
Defined directly by the reach and stack measurements:
\begin{equation*}
\begin{split}
\begin{aligned}
C_x &= \text{Reach} \\
C_z &= \text{Stack}
\end{aligned}
\end{split}
\end{equation*}

\subsubsection{D: Front Tire Contact Point}
\label{\detokenize{Setting the Rig:d-front-tire-contact-point}}
\sphinxAtStartPar
Found by extending from the head tube using fork length, head angle, and rake (offset):
\begin{equation*}
\begin{split}
\begin{aligned}
D_x &= C_x + \cos(\theta_{head}) \cdot L_{fork} - \sin(\theta_{head}) \cdot R_{rake} \\
D_z &= C_z - \sin(\theta_{head}) \cdot L_{fork} - \cos(\theta_{head}) \cdot R_{rake}
\end{aligned}
\end{split}
\end{equation*}
\sphinxAtStartPar
Where \(\theta_{head}\) is the head tube angle, \(L_{fork}\) is the fork length, \(R_{rake}\) is the fork rake (offset).


\subsubsection{E: Rear Tire Contact Point}
\label{\detokenize{Setting the Rig:e-rear-tire-contact-point}}
\sphinxAtStartPar
Located by subtracting the wheelbase from the front tire’s x\sphinxhyphen{}position:
\begin{equation*}
\begin{split}
\begin{aligned}
E_x &= D_x - \text{Wheelbase} \\
E_z &= D_z
\end{aligned}
\end{split}
\end{equation*}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Points}.png}
\caption{Simple illustration of the points’ position.}\label{\detokenize{Setting the Rig:points}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Point A:} Through the A point which will always be set at the (0,0) mark, the B point can be found using the Seat Tube C\sphinxhyphen{}C and the Seat Angle measurements using the polar\sphinxhyphen{}to\sphinxhyphen{}Cartesian coordinate transformation equations as seen above. It is also possible to find the C point by adding the Stack measurement to the Z axis and the Reach measurement to the X axis.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Point B:} Knowing the location of the B point allows us to fully form the Seat Tube, which is needed to be the originator 4 main components of the bike, those being the Chain Stays, Seat Stays, Top Tube and Down Tube.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Point C:} This point is important because it will be the reference point for the Heat Tube and Fork while also completing the Top and Down Tube, it will also act as a reference for the D point. Similarly to how the location for the second point (B), the polar\sphinxhyphen{}to\sphinxhyphen{}Cartesian coordinate transformation equations will be used to find the D point using the measurements: Head Tube, Fork Length, Head Angle with some small corrections using the Rake/Offset.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Point D:} This point will help in placing the wheel and complete the whole front of the bike, that being anything from the Fork to the front wheel, completing the Fork and giving us enough information to complete the rest, it will also help as a reference to find the final point.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Point E:} The final point is needed to place the second wheel and complete the Seat Stays and Chain Stays

\end{itemize}


\section{Constraints and Bone connection}
\label{\detokenize{Setting the Rig:constraints-and-bone-connection}}
\sphinxAtStartPar
The constraints will help the editing process by allowing certain behaviors of the parts while prohibiting unwanted distortion. The list of what constraints will be used and their use is as follows:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Limit Scale:} This forbids the mesh to be scaled in certain axis, for example it can limit the scale of the X axis to minimum=1 and maximum=1 making it unable to be scaled up or down in the X axis.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stretch to:} This constrain is more of a guide, setting a point to which the item will stretch to to have it reach that point whatever happens to that guide object, this can of course lead to various unwanted distortion which is why it will always be paired with the “Limit Scale” constraint.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Track to:} This constraint works similarly to the “Stretch to” constraint without scaling it into the point, making it just face towards the target.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Child of:} By setting one mesh to be the child of another it sets it to copy everything done to the parent, for example if the parent is moved 10 cm to the right, the child will do the same, the same is applied when scaling, rotating and most other actions.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Copy Location:} By having a mesh copy the location of another mesh, it will simply be at the same coordinates as the mesh it is set to, the points of reference that will be in the same place are their individual origin points (usually the center of the object).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Copy Rotation:} Similarly to the “Copy Location” constraint it is possible to set a mesh to copy the exact rotation of a mesh in any selected axes.

\end{itemize}

\sphinxAtStartPar
Similarly the way the bones are connected in an armature is very important as it would be completely different if even one bone is reversed or altered. For example if there are 2 bones linked together in a line like so:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Bones}.png}
\caption{Screenshot taken in blender}\label{\detokenize{Setting the Rig:bones}}\end{figure}

\sphinxAtStartPar
Each sphere represents a point of a bone, in this case they are, in order, placed like this: Head of bone 1, Tail of bone 1 connected to Head of bone 2 and finally Tail of bone 2. If bone 1 is moved as a whole the whole armature will move with it, but if bone 2 is attempted to be moved, only it’s tail will move because it is the “Child” of bone 1 and has less influence. Making it important to set the right bones are the parent bones and child bones.


\section{Constraints and settings for each part}
\label{\detokenize{Setting the Rig:constraints-and-settings-for-each-part}}
\sphinxAtStartPar
A total of 2 armatures were made for this part, one for the frame of the bike and one for the fork and everything attached to it. As seen in the image below the bones highlighted in green make up the armature responsible for the frame and the gray bone is the separate armature for the rest. The armatures are named “AFrame” and “AFork” respectively.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Bike_Rigs}.png}
\caption{Screenshot taken in Blender}\label{\detokenize{Setting the Rig:bike-rigs}}\end{figure}

\sphinxAtStartPar
\sphinxstylestrong{AFork:} The only bone in this is the Fork bone, making it unable to have a parent bone or child bone and needing only 3 simple constraints, these being \sphinxstylestrong{Copy Location} targeting at point C, \sphinxstylestrong{Stretch to} targeting point D practically making it start from C and end at D at any point. The final constraint is \sphinxstylestrong{Limit Scale} which makes it unable to become thinner or wider.

\sphinxAtStartPar
\sphinxstylestrong{AFrame:} For simplicity, for this section, each bone will be named after the part of the bike it represents:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seat Tube:} As seen in the image it is the parent bone of every other bone having all of their heads pointing to it, this allows the seat tube to be transformed while having the rest follow it around. In order to edit it, the head point in set to \sphinxstylestrong{Copy Location} to point A and \sphinxstylestrong{Stretch to} point B while having the \sphinxstylestrong{Limit Scale} on X and Y axes to restrict it from widening or thinning.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Top Tube:} Being the child bone of the Seat Tube bone it’s head will always follow the Seat Tubes tail, making it only need to \sphinxstylestrong{Stretch to} Point C, with some corrections to not meet the Down Tube directly and \sphinxstylestrong{Limit Scale} for the same reasons as the Seat Tube.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Down Tube:} Very similar to Top Tube, it follows the Seat Tube’s head so it only needs to \sphinxstylestrong{Stretch to} point C again with similar corrections and for the same reasons have \sphinxstylestrong{Limit Scale} added.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seat Stays:} Similarly it’s head follows the tail end of the Seat Tube, only needing to \sphinxstylestrong{Stretch to} point E and \sphinxstylestrong{Limit Scale}.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Chain Stays:} Exactly the same as the Seat Stays but instead of following the tail end it follows the head of the Seat Tube.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Drivetrain Parts:} First the chain will be explained as it needed 2 armatures to be completed and then the pedal mechanism which was simpler.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Left Chain part:} This part just needed the \sphinxstylestrong{Copy Location} constraint targeting the E point to ensure that it would stay on the Cassette.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Top Chain part:} An Armature with 1 bone was made with the bone constraints being similar to the ones for tubes, the only difference being this had the \sphinxstylestrong{Copy Location} and \sphinxstylestrong{Stretch to} constraints target custom Empties right above the main points instead of being directly on them to create the illusion that the chain is still 1 object, even though it wasn’t possible. Lastly \sphinxstylestrong{Limit Scale} was added for the same reasons it was added to the tubes.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Down Chain part:} Similarly this part had an armature with the bone being guided with the same constraints to Empties targeting right bellow the main points.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Right Chain part:} This part didn’t need any kind of editing as it will always stay in the (0,0,0) position right in the middle with the A point.

\end{itemize}

\sphinxAtStartPar
As seen in the {\hyperref[\detokenize{Making the Model::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{Making the Model}}}} section, the pedals are made of 4 parts as well. Each pedal needs these 4 parts to make it so the pedals don’t spin in ways that weren’t possible while riding a bike. For simplicity, as shown in the picture in the section mentioned, the start of the pedal will be where it meets the bike and going down will be the end of the pedal.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bottom Bracket:} This is a component that isn’t easily visible but both arms of the pedals have the \sphinxstylestrong{Copy Rotation} targeted to this one object to make sure they are synchronized, of course with the corrections to make it so they are facing opposite directions at all points.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{End part of the pedal:} On an actual bike this would be the screw between the arm and the pedal of the bike, but in this case a small cylinder is added and made the \sphinxstylestrong{Child of} it’s respective arm. This allows it to always be in the same spot on the arm whatever happens to it during any transformation.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pedal:} The actual pedal where the foot rests will only have the \sphinxstylestrong{Copy Location} constraint targeting the End part of the pedal, by having it copy only the location and not making a child to it the pedal always faces right side up.

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Other:} There are several parts that are not part of the frame, therefore not in the armatures, these parts also need certain constraints to function correctly.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seat Post:} Needing the size for it to be placed in the right spot it will be scaled independently making it able to just have \sphinxstylestrong{Track to} with the target being the B point.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seat:} Only has the \sphinxstylestrong{Copy Location} constraint targeting the Seat Post.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Headset:} Work exactly like the Seat Post so it also just has the \sphinxstylestrong{Track to} constraint with the target being the C point.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stem and Handlebars:} The Stem only has the \sphinxstylestrong{Child of} constraint to the Headset part and the Handlebars only \sphinxstylestrong{Copy location} on the Stem making both move with the headset.

\end{itemize}

\sphinxstepscope


\section{The Script}
\label{\detokenize{Edit Script:the-script}}\label{\detokenize{Edit Script::doc}}
\sphinxAtStartPar
This section explains the structure and logic of the Blender editing script used to transform the bike model based on external data.


\subsection{Key Parts of the Script}
\label{\detokenize{Edit Script:key-parts-of-the-script}}

\subsubsection{1. The Rig}
\label{\detokenize{Edit Script:the-rig}}
\sphinxAtStartPar
The ability to use values and transform the bike relies on the rig setup, especially the key points.


\subsubsection{2. Bpy Library}
\label{\detokenize{Edit Script:bpy-library}}
\sphinxAtStartPar
The script uses Blender’s \sphinxcode{\sphinxupquote{bpy}} library, accessed through Blender’s scripting section, to manipulate the model with Python.


\subsubsection{3. Data Acquisition}
\label{\detokenize{Edit Script:data-acquisition}}
\sphinxAtStartPar
All measurements and angles for the bike are stored in an external YAML file, which is loaded into Blender. The YAML structure is as follows (all values in millimeters except angles in degrees, \sphinxcode{\sphinxupquote{Material}} as a string, and \sphinxcode{\sphinxupquote{Top Tube}}/\sphinxcode{\sphinxupquote{Down Tube}} as booleans):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nt}{Frame}\PYG{p}{:}
\PYG{err}{	}\PYG{n+nt}{Fork Lenght}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{470}
\PYG{err}{	}\PYG{n+nt}{Head Angle}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{69.5}
\PYG{err}{	}\PYG{n+nt}{Head Tube}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{130}
\PYG{err}{	}\PYG{n+nt}{Rake Offset}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{40}
\PYG{err}{	}\PYG{n+nt}{Reach}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{380}
\PYG{err}{	}\PYG{n+nt}{Seat Angle}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{73}
\PYG{err}{	}\PYG{n+nt}{Seat Tube}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{375}
\PYG{err}{	}\PYG{n+nt}{Stack}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{620}
\PYG{err}{	}\PYG{n+nt}{Wheelbase}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{1080}
\PYG{n+nt}{Frame Details}\PYG{p}{:}
\PYG{err}{	}\PYG{n+nt}{Diameter}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{40}
\PYG{err}{	}\PYG{n+nt}{Down Tube}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{True}
\PYG{err}{	}\PYG{n+nt}{Material}\PYG{p}{:}\PYG{+w}{ }\PYG{l+s}{\PYGZsq{}}\PYG{l+s}{Metal}\PYG{l+s}{\PYGZsq{}}
\PYG{err}{	}\PYG{n+nt}{Thickness}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{2}
\PYG{err}{	}\PYG{n+nt}{Top Tube}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{True}
\PYG{n+nt}{Handlebar}\PYG{p}{:}
\PYG{err}{	}\PYG{n+nt}{Handlebar Height}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{50}
\PYG{err}{	}\PYG{n+nt}{HandleBar Lenght}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{400}
\PYG{n+nt}{Seat}\PYG{p}{:}
\PYG{err}{	}\PYG{n+nt}{Seat Post}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{150}
\PYG{n+nt}{Wheels}\PYG{p}{:}
\PYG{err}{	}\PYG{n+nt}{Tire Radius}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{700}
\PYG{err}{	}\PYG{n+nt}{Tire Width}\PYG{p}{:}\PYG{+w}{ }\PYG{l+lScalar+lScalarPlain}{40}
\end{sphinxVerbatim}


\subsubsection{4. Set\_Point(“name”, X, Z) Function}
\label{\detokenize{Edit Script:set-point-name-x-z-function}}
\sphinxAtStartPar
Moves any object to a specified location. Takes the object’s name and X, Z coordinates (Y remains 0), sets the coordinates, selects and moves the object, then deselects everything to avoid accidental multi\sphinxhyphen{}object moves.


\subsubsection{5. Set\_Scale(“name”, X, Y, Z) Function}
\label{\detokenize{Edit Script:set-scale-name-x-y-z-function}}
\sphinxAtStartPar
Scales objects to the required size. Receives the object’s name and scale for each axis. A value of 0 (or less) leaves that axis unchanged, allowing selective scaling. After scaling, the function resets the scale to default and deselects everything.


\subsubsection{6. Small Corrections/Adjustments}
\label{\detokenize{Edit Script:small-corrections-adjustments}}
\sphinxAtStartPar
Some parts need to be offset from main points for design reasons. These are moved last and follow the rest of the parts, using the two functions above.


\subsubsection{7. Wheel Adjustments}
\label{\detokenize{Edit Script:wheel-adjustments}}
\sphinxAtStartPar
The script includes a section focused on adjusting the tires and wheels to match the data using the \sphinxcode{\sphinxupquote{Set\_Scale()}} function.


\bigskip\hrule\bigskip



\subsection{Editing Process}
\label{\detokenize{Edit Script:editing-process}}\begin{quote}

\sphinxAtStartPar
\sphinxstylestrong{Note:} The code below is simplified for clarity. Variable names are shown directly (e.g., \sphinxcode{\sphinxupquote{Head Angle}}), but in the actual code, they are accessed as \sphinxcode{\sphinxupquote{data{[}'Frame'{]}{[}'Head Angle'{]}}}. In \sphinxcode{\sphinxupquote{Set\_Scale}}, X and Y are written on separate lines for readability.
\end{quote}


\subsubsection{Step 1: Data Preparation}
\label{\detokenize{Edit Script:step-1-data-preparation}}
\sphinxAtStartPar
Read and adjust the data for calculations—convert angles to radians and add the Head Tube size to the Fork Length for accurate front wheel placement:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{yaml\PYGZus{}file\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{file}\PYG{p}{:}
		\PYG{n}{data} \PYG{o}{=} \PYG{n}{yaml}\PYG{o}{.}\PYG{n}{safe\PYGZus{}load}\PYG{p}{(}\PYG{n}{file}\PYG{p}{)}

\PYG{n}{Head\PYGZus{}Angle} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{Head\PYGZus{}Angle}\PYG{p}{)}
\PYG{n}{Seat\PYGZus{}Angle} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{radians}\PYG{p}{(}\PYG{n}{Seat\PYGZus{}Angle}\PYG{p}{)}
\PYG{n}{Fork\PYGZus{}Length} \PYG{o}{=} \PYG{n}{Fork\PYGZus{}Length} \PYG{o}{+} \PYG{n}{Head\PYGZus{}Tube}
\end{sphinxVerbatim}


\subsubsection{Step 2: Placing Key Points}
\label{\detokenize{Edit Script:step-2-placing-key-points}}
\sphinxAtStartPar
Assign X and Z values for each point and use \sphinxcode{\sphinxupquote{Set\_Point()}} to move them. For example, to move the B point (see {\hyperref[\detokenize{Setting the Rig::doc}]{\sphinxcrossref{\DUrole{std,std-doc}{Setting the Rig}}}}):

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{Seat\PYGZus{}Angle}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Seat\PYGZus{}Tube} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{Seat\PYGZus{}Angle}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Seat\PYGZus{}Tube} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Set\PYGZus{}Point}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Step 3: Small Adjustments}
\label{\detokenize{Edit Script:step-3-small-adjustments}}
\sphinxAtStartPar
Make corrections for the Head Tube and D point to account for Rake/Offset:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X} \PYG{o}{=} \PYG{n}{Reach} \PYG{o}{/} \PYG{l+m+mi}{1000} \PYG{o}{+} \PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{Head\PYGZus{}Angle}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Fork\PYGZus{}Length} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{Stack} \PYG{o}{/} \PYG{l+m+mi}{1000} \PYG{o}{\PYGZhy{}} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{Head\PYGZus{}Angle}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Fork\PYGZus{}Length} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Set\PYGZus{}Point}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{D}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}

\PYG{n}{X} \PYG{o}{=} \PYG{n}{X} \PYG{o}{\PYGZhy{}} \PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{Head\PYGZus{}Angle} \PYG{o}{+} \PYG{l+m+mi}{90}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Rake} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{Z} \PYG{o}{\PYGZhy{}} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{Head\PYGZus{}Angle} \PYG{o}{+} \PYG{l+m+mi}{90}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{n}{Rake} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Set\PYGZus{}Point}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SizeF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Step 4: Placing and Scaling Non\sphinxhyphen{}Frame Parts}
\label{\detokenize{Edit Script:step-4-placing-and-scaling-non-frame-parts}}
\sphinxAtStartPar
Move and scale parts like the handle and seat:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{X} \PYG{o}{=} \PYG{o}{\PYGZhy{}}\PYG{n}{math}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{Seat\PYGZus{}Angle}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{Seat\PYGZus{}Tube} \PYG{o}{+} \PYG{n}{Seat\PYGZus{}Post}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Z} \PYG{o}{=} \PYG{n}{math}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{Seat\PYGZus{}Angle}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}\PYG{p}{(}\PYG{n}{Seat\PYGZus{}Tube} \PYG{o}{+} \PYG{n}{Seat\PYGZus{}Post}\PYG{p}{)} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Set\PYGZus{}Point}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Seat Post}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{X}\PYG{p}{,} \PYG{n}{Z}\PYG{p}{)}

\PYG{n}{Set\PYGZus{}Scale}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Seat Post}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Seat\PYGZus{}Post} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\end{sphinxVerbatim}


\subsubsection{Step 5: Wheel Transformations}
\label{\detokenize{Edit Script:step-5-wheel-transformations}}
\sphinxAtStartPar
Transform wheels as needed using \sphinxcode{\sphinxupquote{Set\_Scale()}}:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Set\PYGZus{}Scale}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FTire}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Wheel\PYGZus{}Thickness} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}
\PYG{n}{Set\PYGZus{}Scale}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BTire}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{Wheel\PYGZus{}Thickness} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{)}

\PYG{n}{Set\PYGZus{}Scale}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SizeF}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Wheel\PYGZus{}Size} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{Wheel\PYGZus{}Size} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\PYG{n}{Set\PYGZus{}Scale}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{SizeB}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{Wheel\PYGZus{}Size} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{n}{Wheel\PYGZus{}Size} \PYG{o}{/} \PYG{l+m+mi}{1000}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Examples}
\label{\detokenize{Edit Script:examples}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{examples}.png}
\caption{Four example bikes made with the code.}\label{\detokenize{Edit Script:id1}}\end{figure}

\sphinxstepscope


\section{Biker}
\label{\detokenize{Biker:biker}}\label{\detokenize{Biker::doc}}
\sphinxAtStartPar
This section describes the setup and constraints used for the biker model and its armature, ensuring correct positioning and animation on any generated bike.


\subsection{Model Setup}
\label{\detokenize{Biker:model-setup}}
\sphinxAtStartPar
The biker model and it’s armature is the same as the one used for pedestrians in the simulation. The focus here is on editing the armature so that the biker sits correctly, with arms and legs in the right places for any bike created by the script. While the biker is not required for the simulation to function he is used for the loading animation.

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Biker}.png}
\caption{Screenshot taken in Blender showing the Armature of the biker}\label{\detokenize{Biker:id1}}\end{figure}


\subsubsection{Reference Points (Empties)}
\label{\detokenize{Biker:reference-points-empties}}
\sphinxAtStartPar
The model does not have collision, so to ensure the biker sits on or touches the bike and not be inside it, several empties are created as reference points:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Seat:} An empty is placed slightly above the seat mesh, which becomes its parent. This ensures the seat reference is always in the correct place for the biker to sit.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Handlebars:} Two empties are placed over the handlebar (one for each hand), both parented to the handlebar so they move with it.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pedals:} One empty is placed over each pedal, parented to the respective pedal, ensuring the biker’s feet are always positioned correctly.

\end{itemize}


\subsection{Armature Constraints}
\label{\detokenize{Biker:armature-constraints}}
\sphinxAtStartPar
The main constraints used are:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Inverse Kinematic (IK):} Allows the ends of limbs to follow a target point, with the rest of the limb (e.g., elbows, knees) bending naturally. This constraint appears orange in Blender’s editor.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Limit Rotation:} Restricts rotation to a specified range, preventing unnatural movement.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Copy Location:} Used for the hip to follow the seat.

\end{itemize}


\subsubsection{Constraint Setup}
\label{\detokenize{Biker:constraint-setup}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Hands:} IK constraint targets the handlebar empties; Limit Rotation keeps hands parallel to the floor and prevents collision with the bar.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Hip:} Copy Location constraint targets the seat empty.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Head:} Limit Rotation constraint keeps the head facing forward.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Biker_Top}.png}
\caption{Picture showcasing the upper body.}\label{\detokenize{Biker:biker-top}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Feet:} IK constraint targets the pedal empties.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Shins:} Limit Rotation constraint prevents unnatural bending due to IK.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Toes:} Limit Rotation keeps toes facing forward (for realism, not function).

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Biker_Bot}.png}
\caption{Picture showcasing the lower body.}\label{\detokenize{Biker:biker-bot}}\end{figure}


\subsection{Final Result}
\label{\detokenize{Biker:final-result}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Biker_All}.png}
\caption{Final result of biker.}\label{\detokenize{Biker:biker-all}}\end{figure}

\sphinxstepscope


\chapter{Simulation Engine}
\label{\detokenize{Unity:simulation-engine}}\label{\detokenize{Unity::doc}}

\section{Unity}
\label{\detokenize{Unity:unity}}
\sphinxAtStartPar
Unity is a powerful, cross\sphinxhyphen{}platform game engine and development environment that has become increasingly popular for creating real\sphinxhyphen{}time 3D simulations and interactive applications beyond traditional gaming. Originally designed for game development, Unity’s robust physics engine, comprehensive scripting capabilities, and extensive asset pipeline make it an ideal platform for scientific simulations, urban planning visualizations, and mobility studies.

\sphinxAtStartPar
Unity serves as the central platform where all components of our active movement simulation converge. Its real\sphinxhyphen{}time rendering capabilities allow for dynamic visualization of complex urban environments, while its physics engine enables realistic simulation of bicycle movement and rider behavior. Unity’s support for geospatial data integration, particularly through plugins like Cesium for Unity, makes it possible to create accurate representations of real\sphinxhyphen{}world built environments.


\section{Why unity}
\label{\detokenize{Unity:why-unity}}
\sphinxAtStartPar
The choice of Unity for this project is driven by several key advantages:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Real\sphinxhyphen{}time simulation}: Enables interactive exploration and immediate feedback on simulation parameters

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Physics integration}: Provides realistic movement dynamics for both bicycles and pedestrians

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Geospatial support}: Seamless integration with Cesium SDK for accurate geographic representation

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Extensible scripting}: C\# scripting environment for implementing custom mobility algorithms and data collection

\end{itemize}

\sphinxstepscope


\chapter{NavMesh}
\label{\detokenize{Navmesh:navmesh}}\label{\detokenize{Navmesh::doc}}
\sphinxAtStartPar
A \sphinxstylestrong{NavMesh} (short for \sphinxstyleemphasis{Navigation Mesh}) is a data structure used in Unity and other game engines to facilitate pathfinding for agents in a virtual environment. NavMeshes define the walkable areas of a scene, allowing agents to navigate the environment realistically and avoid obstacles.


\section{How NavMesh Works In Unity?}
\label{\detokenize{Navmesh:how-navmesh-works-in-unity}}
\sphinxAtStartPar
Τhe NavMesh is generated by marking the navigable areas on a terrain or game level. The NavMesh system uses this data to determine the shortest or most efficient path for an agent to move from one point to another. Unity’s NavMesh system involves three key components:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMesh Agent}: Represents the entity that will navigate the NavMesh, such as an NPC. Agents are assigned properties like speed and acceleration, which influence their movement behavior. The NavMesh Agent component is responsible for finding paths and moving the agent along them .

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMesh Surface}: Defines that the NavMesh covers. By baking the NavMesh Surface, Unity generates the navigation mesh based on obstacles, walkable surfaces, and other parameters defined within the NavMesh settings .

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMesh Obstacles}: Allow obstele to be added to the NavMesh. Obstacles are particularly useful for scenarios with moving objects that agents need to navigate around. Unity provides options to set obstacles as either static (stationary) or dynamic (movable), affecting the way agents interact with these objects .

\end{enumerate}


\section{Generating the NavMesh}
\label{\detokenize{Navmesh:generating-the-navmesh}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{navmeshsurface}.png}
\caption{NavMesh Surface Component in Unity}\label{\detokenize{Navmesh:navmesh-surface}}\end{figure}

\sphinxAtStartPar
To generate the NavMesh, we use the \sphinxstylestrong{NavMesh Surface} component. Below are the key fields and their purposes:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Agent Type}:\\
Specifies the type of agent (e.g., pedestrian, bicycle) for which the NavMesh is being generated. We are going to dive into more detail in the following chapters

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Default Area}:\\
Defines the default area type (e.g., Walkable) for the NavMesh. This determines where agents can navigate.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Generate Links}:\\
Enables or disables the generation of off\sphinxhyphen{}mesh links, which allow agents to traverse gaps or jumps between surfaces.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Object Collection}:\\
Determines which objects in the scene are included when baking the NavMesh. This can be set to include all objects or only specific ones.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{navmesh}.png}
\caption{Generated Navmesh for human actors}\label{\detokenize{Navmesh:id1}}\end{figure}

\sphinxAtStartPar
After configuring these fields, the NavMesh can be generated. Once baked, a blue overlay appears on the geometry, visually indicating the walkable areas that the \sphinxstylestrong{NavMesh Agent} can traverse.

\sphinxstepscope


\chapter{NavMesh Agent}
\label{\detokenize{Navmesh Agent:navmesh-agent}}\label{\detokenize{Navmesh Agent::doc}}
\sphinxAtStartPar
A NavMesh Agent is a Unity component that enables game objects to navigate intelligently across a NavMesh (Navigation Mesh). The NavMesh Agent acts as the “brain” for movement, allowing objects to pathfind, avoid obstacles, and move through complex environments automatically.


\section{What is a NavMesh Agent?}
\label{\detokenize{Navmesh Agent:what-is-a-navmesh-agent}}
\sphinxAtStartPar
In Unity’s navigation system, a NavMesh Agent represents any entity that needs to move through the environment autonomously. The agent uses the underlying NavMesh to calculate optimal paths from its current position to a target destination, taking into account obstacles, terrain variations, and other environmental factors.

\sphinxAtStartPar
The NavMesh Agent component abstracts the complexity of pathfinding and movement, providing a high\sphinxhyphen{}level interface for controlling navigation behavior. Instead of manually programming movement logic, developers can simply set a destination, and the agent will automatically navigate to that location using the most efficient route available.


\section{Core Properties and Configuration}
\label{\detokenize{Navmesh Agent:core-properties-and-configuration}}
\sphinxAtStartPar
The NavMesh Agent component includes several key categories of properties that define how the agent behaves:


\subsection{Agent Configuration}
\label{\detokenize{Navmesh Agent:agent-configuration}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Agent Type}: Defines the size and movement characteristics template for the agent

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Base Offset}: Vertical offset from the NavMesh surface to the agent’s pivot point

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Speed}: Maximum movement speed in Unity units per second

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Angular Speed}: How fast the agent can rotate (degrees per second)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Acceleration}: Rate at which the agent reaches its target speed

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stopping Distance}: Distance from the target at which the agent will stop

\end{itemize}


\subsection{Steering Behavior}
\label{\detokenize{Navmesh Agent:steering-behavior}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Braking}: Whether the agent slows down when approaching the destination

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Radius}: The agent’s collision radius for navigation purposes

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Height}: The agent’s height for clearance calculations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Quality}: Level of detail for obstacle avoidance calculations (None, Low, Medium, High)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Priority}: Relative importance when multiple agents need to resolve navigation conflicts (0\sphinxhyphen{}99)

\end{itemize}


\subsection{Pathfinding Settings}
\label{\detokenize{Navmesh Agent:pathfinding-settings}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Traverse Off Mesh Link}: Automatically moves across NavMesh connections and jumps

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Repath}: Recalculates path when the current route becomes invalid

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Area Mask}: Defines which NavMesh areas the agent can traverse

\end{itemize}


\section{Applications in Active Mobility Simulation}
\label{\detokenize{Navmesh Agent:applications-in-active-mobility-simulation}}
\sphinxAtStartPar
In the context of this thesis’s active mobility simulation, NavMesh Agents serve as the foundation for realistic movement behavior of both cyclists and pedestrians. By configuring agents with appropriate parameters that reflect real\sphinxhyphen{}world movement characteristics, the simulation can accurately model:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pathfinding}: Agents find optimal routes through urban environments

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Obstacle Avoidance}: Dynamic collision avoidance between different types of mobility agents

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Mixed Traffic Scenarios}: Interaction between bicycles, pedestrians, and other mobility modes

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Environmental Navigation}: Realistic movement across varied terrain and infrastructure

\end{itemize}

\sphinxAtStartPar
The flexibility of the NavMesh Agent system allows for fine\sphinxhyphen{}tuning movement parameters to match different mobility types, from the faster, wider turning radius of bicycles to the more agile movement patterns of pedestrians.

\sphinxstepscope


\section{Bicycle Agent}
\label{\detokenize{Bicycle Agent:bicycle-agent}}\label{\detokenize{Bicycle Agent::doc}}
\sphinxAtStartPar
The bicycle serves as the primary NavMesh Agent in this active mobility simulation, representing realistic cycling behavior within urban environments generated from real\sphinxhyphen{}world geospatial data.


\subsection{Overview}
\label{\detokenize{Bicycle Agent:overview}}
\sphinxAtStartPar
The bicycle agent leverages Unity’s NavMesh system to navigate complex terrain, avoid obstacles, and follow both predefined paths and dynamically calculated routes based on CSV data or manual path creation.


\subsection{NavMesh Agent Configuration}
\label{\detokenize{Bicycle Agent:navmesh-agent-configuration}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{bicycleagent}.png}
\caption{Nav Mesh Agent \sphinxhyphen{} Bicycle Configuration}\label{\detokenize{Bicycle Agent:id1}}\end{figure}

\sphinxAtStartPar
The \sphinxstylestrong{NavMesh Agent} component is configured with specific parameters that define realistic bicycle movement characteristics:


\subsubsection{Agent Properties}
\label{\detokenize{Bicycle Agent:agent-properties}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Base Offset}: \sphinxcode{\sphinxupquote{0.25}} \sphinxhyphen{} Ensures proper positioning relative to the NavMesh surface, accounting for wheel contact

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Speed}: \sphinxcode{\sphinxupquote{3.5}} Unity units \sphinxhyphen{} Represents maximum cycling speed

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Angular Speed}: \sphinxcode{\sphinxupquote{120}} degrees/second \sphinxhyphen{} Allows smooth turning without unrealistic sharp changes

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Acceleration}: \sphinxcode{\sphinxupquote{8}} \sphinxhyphen{} Enables gradual speed changes for realistic movement

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stopping Distance}: \sphinxcode{\sphinxupquote{0}} \sphinxhyphen{} Provides precise stopping behavior at destinations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Braking}: Enabled \sphinxhyphen{} Smooth deceleration when approaching obstacles

\end{itemize}


\subsubsection{Obstacle Avoidance}
\label{\detokenize{Bicycle Agent:obstacle-avoidance}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Radius}: \sphinxcode{\sphinxupquote{0.5}} \sphinxhyphen{} Defines collision boundary for navigation, accounting for bicycle width

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Height}: \sphinxcode{\sphinxupquote{0.9}} \sphinxhyphen{} Matches the bicycle’s vertical clearance requirements

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Quality}: High Quality \sphinxhyphen{} Prioritizes accuracy in obstacle detection and avoidance

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Priority}: \sphinxcode{\sphinxupquote{50}} \sphinxhyphen{} Balanced importance for navigation conflict resolution

\end{itemize}


\subsubsection{Pathfinding}
\label{\detokenize{Bicycle Agent:pathfinding}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Traverse Off Mesh Link}: Enabled \sphinxhyphen{} Allows navigation over gaps and connections

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Repath}: Enabled \sphinxhyphen{} Dynamic route recalculation when paths become blocked

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Area Mask}: Everything \sphinxhyphen{} Permits traversal across all walkable NavMesh areas

\end{itemize}


\subsection{Functionality and Behavior}
\label{\detokenize{Bicycle Agent:functionality-and-behavior}}

\subsubsection{Movement Systems}
\label{\detokenize{Bicycle Agent:movement-systems}}
\sphinxAtStartPar
The bicycle agent implements multiple movement modes:


\paragraph{1. CSV Data Navigation}
\label{\detokenize{Bicycle Agent:csv-data-navigation}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Reads bicycle trip data from CSV files containing X, Y, Z coordinates

\item {} 
\sphinxAtStartPar
Traverses real\sphinxhyphen{}world cycling routes imported as position data

\item {} 
\sphinxAtStartPar
Provides realistic movement patterns based on actual cycling behavior

\end{itemize}


\paragraph{2. Path\sphinxhyphen{}Based Navigation}
\label{\detokenize{Bicycle Agent:path-based-navigation}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Follows predefined paths created using NavMeshPathCreator

\item {} 
\sphinxAtStartPar
Supports looping behavior for continuous simulation

\item {} 
\sphinxAtStartPar
Maintains smooth progression between waypoints

\end{itemize}


\subsubsection{Obstacle Detection and Avoidance}
\label{\detokenize{Bicycle Agent:obstacle-detection-and-avoidance}}
\sphinxAtStartPar
The bicycle implements sophisticated obstacle detection:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{// Sphere casting for obstacle detection}
\PYG{n}{Vector3}\PYG{+w}{ }\PYG{n}{p1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{transform}\PYG{p}{.}\PYG{n}{position}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{n}{\PYGZus{}agent}\PYG{p}{.}\PYG{n}{height}\PYG{+w}{ }\PYG{o}{/}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{Vector3}\PYG{p}{.}\PYG{n}{up}\PYG{p}{;}
\PYG{k+kt}{float}\PYG{+w}{ }\PYG{n}{sphereDistance}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{\PYGZus{}agent}\PYG{p}{.}\PYG{n}{stoppingDistance}\PYG{p}{;}
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{mask}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{LayerMask}\PYG{p}{.}\PYG{n}{GetMask}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Humans\PYGZdq{}}\PYG{p}{)}\PYG{p}{;}

\PYG{k}{if}\PYG{p}{(}\PYG{n}{Physics}\PYG{p}{.}\PYG{n}{SphereCast}\PYG{p}{(}\PYG{n}{p1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sphereDistance}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{transform}\PYG{p}{.}\PYG{n}{forward}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{out}\PYG{+w}{ }\PYG{n}{RaycastHit}\PYG{+w}{ }\PYG{n}{hit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{sphereDistance}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{mask}\PYG{p}{)}\PYG{p}{)}\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{\PYGZus{}agent}\PYG{p}{.}\PYG{n}{isStopped}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{k}{true}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// Stop when humans detected}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Key Features:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Sphere Casting}: Detects obstacles in the forward direction

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Human Detection}: Specifically identifies pedestrian obstacles using layer masking

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Dynamic Stopping}: Automatically stops when obstacles are detected

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Resumption}: Continues movement when path is clear

\end{itemize}


\subsubsection{State Management}
\label{\detokenize{Bicycle Agent:state-management}}
\sphinxAtStartPar
The bicycle agent responds to different simulation states:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Setup State}: Allows configuration and parameter adjustment

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Simulation State}: Active navigation and movement

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Camera Integration}: Cinemachine virtual camera for following and observation

\end{itemize}


\subsubsection{Interactive Features}
\label{\detokenize{Bicycle Agent:interactive-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Click Selection}: Mouse interaction for agent selection during setup

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Camera Following}: Priority\sphinxhyphen{}based camera switching for observation

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Visual Debugging}: Gizmos showing detection spheres and stopping distances

\end{itemize}


\subsection{Technical Implementation}
\label{\detokenize{Bicycle Agent:technical-implementation}}

\subsubsection{Key Components}
\label{\detokenize{Bicycle Agent:key-components}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMeshAgent}: Core navigation component

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CSVReader}: Data import for real\sphinxhyphen{}world route following

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CinemachineVirtualCamera}: Camera control for observation

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMeshPathCreator}: Custom path definition tool

\end{itemize}


\subsubsection{Performance Considerations}
\label{\detokenize{Bicycle Agent:performance-considerations}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Efficient sphere casting for obstacle detection

\item {} 
\sphinxAtStartPar
Optimized pathfinding with automatic rerouting

\item {} 
\sphinxAtStartPar
Frame\sphinxhyphen{}rate independent movement using FixedUpdate for physics

\end{itemize}

\sphinxAtStartPar
This configuration enables realistic bicycle simulation within urban environments, supporting research into active mobility patterns and infrastructure optimization.

\sphinxstepscope


\section{Human Agent}
\label{\detokenize{Human Agent:human-agent}}\label{\detokenize{Human Agent::doc}}
\sphinxAtStartPar
Human agents represent pedestrians within the active mobility simulation, providing realistic pedestrian behavior and enabling the study of mixed mobility scenarios involving both cyclists and pedestrians.


\subsection{Overview}
\label{\detokenize{Human Agent:overview}}
\sphinxAtStartPar
Human agents use Unity’s NavMesh system to simulate realistic pedestrian movement patterns, including both structured path following and random wandering behavior. These agents interact dynamically with the environment and other mobility agents, particularly bicycles.


\subsection{NavMesh Agent Configuration}
\label{\detokenize{Human Agent:navmesh-agent-configuration}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{humanagent}.png}
\caption{Nav Mesh Agent \sphinxhyphen{} Human Configuration}\label{\detokenize{Human Agent:id1}}\end{figure}

\sphinxAtStartPar
The human \sphinxstylestrong{NavMesh Agent} component is configured to replicate realistic pedestrian movement characteristics:


\subsubsection{Agent Properties}
\label{\detokenize{Human Agent:agent-properties}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Base Offset}: \sphinxcode{\sphinxupquote{0}} \sphinxhyphen{} Direct alignment with NavMesh surface for natural walking

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Speed}: \sphinxcode{\sphinxupquote{3.5}} Unity units \sphinxhyphen{} Represents typical human walking speed

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Angular Speed}: \sphinxcode{\sphinxupquote{120}} degrees/second \sphinxhyphen{} Enables smooth and natural turning

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Acceleration}: \sphinxcode{\sphinxupquote{8}} \sphinxhyphen{} Gradual speed changes for realistic movement

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stopping Distance}: \sphinxcode{\sphinxupquote{0}} \sphinxhyphen{} Accurate stopping behavior at destinations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Braking}: Enabled \sphinxhyphen{} Smooth deceleration when obstacles are detected

\end{itemize}


\subsubsection{Obstacle Avoidance}
\label{\detokenize{Human Agent:obstacle-avoidance}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Radius}: \sphinxcode{\sphinxupquote{0.25}} \sphinxhyphen{} Smaller collision boundary suitable for human body width

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Height}: \sphinxcode{\sphinxupquote{1.83}} \sphinxhyphen{} Corresponds to average human height

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Quality}: High Quality \sphinxhyphen{} Accurate obstacle avoidance calculations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Priority}: \sphinxcode{\sphinxupquote{50}} \sphinxhyphen{} Equal importance with bicycle agents for conflict resolution

\end{itemize}


\subsubsection{Pathfinding}
\label{\detokenize{Human Agent:pathfinding}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Traverse Off Mesh Link}: Enabled \sphinxhyphen{} Navigation across separate NavMesh areas

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Repath}: Enabled \sphinxhyphen{} Dynamic path adjustment when routes become blocked

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Area Mask}: Everything \sphinxhyphen{} Full access to all walkable areas

\end{itemize}


\subsection{Functionality and Behavior}
\label{\detokenize{Human Agent:functionality-and-behavior}}

\subsubsection{Movement Systems}
\label{\detokenize{Human Agent:movement-systems}}
\sphinxAtStartPar
The human agent implements multiple movement patterns:


\paragraph{1. Random Movement}
\label{\detokenize{Human Agent:random-movement}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{var}\PYG{+w}{ }\PYG{n}{randomDirection}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{Random}\PYG{p}{.}\PYG{n}{insideUnitSphere}\PYG{+w}{ }\PYG{o}{*}\PYG{+w}{ }\PYG{n}{randomDestinationRadius}\PYG{p}{;}
\PYG{n}{randomDirection}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{n}{transform}\PYG{p}{.}\PYG{n}{position}\PYG{p}{;}

\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{NavMesh}\PYG{p}{.}\PYG{n}{SamplePosition}\PYG{p}{(}\PYG{n}{randomDirection}\PYG{p}{,}\PYG{+w}{ }\PYG{k}{out}\PYG{+w}{ }\PYG{n}{NavMeshHit}\PYG{+w}{ }\PYG{n}{hit}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{randomDestinationRadius}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{\PYGZus{}agent}\PYG{p}{.}\PYG{n}{SetDestination}\PYG{p}{(}\PYG{n}{hit}\PYG{p}{.}\PYG{n}{position}\PYG{p}{)}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Features:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Configurable Radius}: Adjustable area for random destination selection (\sphinxcode{\sphinxupquote{randomDestinationRadius}})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Wait Time Variation}: Random wait periods between movements (\sphinxcode{\sphinxupquote{randomWaitTimeRange}})

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMesh Validation}: Ensures destinations are on walkable surfaces

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Natural Behavior}: Simulates realistic pedestrian wandering patterns

\end{itemize}


\paragraph{2. Path\sphinxhyphen{}Based Movement}
\label{\detokenize{Human Agent:path-based-movement}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Follows predefined paths using NavMeshPathCreator

\item {} 
\sphinxAtStartPar
Sequential waypoint navigation with smooth transitions

\item {} 
\sphinxAtStartPar
Optional looping for continuous pedestrian flow

\item {} 
\sphinxAtStartPar
Arrival detection with configurable distance threshold (2.5 units)

\end{itemize}


\subsubsection{Animation Integration}
\label{\detokenize{Human Agent:animation-integration}}
\sphinxAtStartPar
The human agent includes sophisticated animation control through a custom \sphinxstylestrong{Animator Controller} system designed to enhance the realism of agent movement in the simulation.


\paragraph{Animation System and State Management}
\label{\detokenize{Human Agent:animation-system-and-state-management}}
\sphinxAtStartPar
The animation system is built around two key components:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Entry and Initial Movement}: The animation system begins at the Entry point and proceeds into the \sphinxstylestrong{Movement} state. This ensures that the animation logic is initiated when the simulation starts.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{animation}.png}
\caption{Animation Controller Entry and Movement State}\label{\detokenize{Human Agent:animation-controller}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Blend Tree for Dynamic Movements}: A \sphinxstylestrong{Blend Tree} allows for fluid transitions between different walking animations and an idle state. Controlled by the \sphinxcode{\sphinxupquote{MoveX}} and \sphinxcode{\sphinxupquote{MoveY}} parameters, the Blend Tree dynamically adjusts the character’s animations to match the direction and speed of movement.

\end{itemize}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{blendtree}.png}
\caption{Blend Tree for Dynamic Movement Animations}\label{\detokenize{Human Agent:blend-tree}}\end{figure}


\paragraph{Animation Value Updates}
\label{\detokenize{Human Agent:animation-value-updates}}
\sphinxAtStartPar
The animation values of the blend tree are set through a script in the human controller:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{private}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{UpdateAnimationValues}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{n}{Vector3}\PYG{+w}{ }\PYG{n}{localVelocity}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{transform}\PYG{p}{.}\PYG{n}{InverseTransformDirection}\PYG{p}{(}\PYG{n}{\PYGZus{}agent}\PYG{p}{.}\PYG{n}{velocity}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{\PYGZus{}animator}\PYG{p}{.}\PYG{n}{SetFloat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}MoveX\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{localVelocity}\PYG{p}{.}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{\PYGZus{}animator}\PYG{p}{.}\PYG{n}{SetFloat}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}MoveY\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{localVelocity}\PYG{p}{.}\PYG{n}{z}\PYG{p}{)}\PYG{p}{;}\PYG{+w}{ }
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{Animation Features:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Velocity\sphinxhyphen{}Based Animation}: Movement animations driven by actual agent velocity

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Directional Movement}: Separate X and Y movement parameters for blend trees

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Smooth Transitions}: Continuous animation updates for natural movement

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Local Space Calculations}: Relative velocity for accurate directional animations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{State\sphinxhyphen{}Driven Logic}: Animation states that respond to simulation flow

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Blend Tree Control}: Dynamic animation blending based on movement direction and speed

\end{itemize}


\subsubsection{State Management}
\label{\detokenize{Human Agent:state-management}}
\sphinxAtStartPar
Human agents respond to simulation state changes:


\paragraph{Game State Integration}
\label{\detokenize{Human Agent:game-state-integration}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{private}\PYG{+w}{ }\PYG{k}{void}\PYG{+w}{ }\PYG{n+nf}{OnGameStateChanged}\PYG{p}{(}\PYG{p}{)}
\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{GameManager}\PYG{p}{.}\PYG{n}{Instance}\PYG{p}{.}\PYG{n}{CurrentGameState}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{GameManager}\PYG{p}{.}\PYG{n}{GameState}\PYG{p}{.}\PYG{n}{Simulation}\PYG{p}{)}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{StartMovement}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{k}{else}
\PYG{+w}{    }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{StopMovement}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}

\sphinxAtStartPar
\sphinxstylestrong{State Behaviors:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Setup State}: Configuration and parameter adjustment mode

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Simulation State}: Active movement and navigation

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Automatic Control}: Starts/stops movement based on simulation state

\end{itemize}


\subsubsection{Interactive Features}
\label{\detokenize{Human Agent:interactive-features}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Click Selection}: Mouse interaction for agent selection during setup phase

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Camera Control}: Integration with Cinemachine virtual cameras

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Visual Debugging}: Real\sphinxhyphen{}time movement visualization and parameter adjustment

\end{itemize}


\subsection{Technical Implementation}
\label{\detokenize{Human Agent:technical-implementation}}

\subsubsection{Core Components}
\label{\detokenize{Human Agent:core-components}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMeshAgent}: Primary navigation component

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Animator}: Character animation control

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{CinemachineVirtualCamera}: Camera system integration

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{NavMeshPathCreator}: Path definition tool

\end{itemize}


\subsubsection{Movement Coroutines}
\label{\detokenize{Human Agent:movement-coroutines}}
\sphinxAtStartPar
The human agent uses efficient coroutine\sphinxhyphen{}based movement:


\paragraph{Random Movement Coroutine}
\label{\detokenize{Human Agent:random-movement-coroutine}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Non\sphinxhyphen{}blocking random destination selection

\item {} 
\sphinxAtStartPar
Configurable wait times between movements

\item {} 
\sphinxAtStartPar
Automatic NavMesh validation

\end{itemize}


\paragraph{Path Following Coroutine}
\label{\detokenize{Human Agent:path-following-coroutine}}\begin{itemize}
\item {} 
\sphinxAtStartPar
Sequential waypoint navigation

\item {} 
\sphinxAtStartPar
Distance\sphinxhyphen{}based arrival detection

\item {} 
\sphinxAtStartPar
Loop support for continuous flow

\end{itemize}


\subsubsection{Performance Optimizations}
\label{\detokenize{Human Agent:performance-optimizations}}\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Coroutine\sphinxhyphen{}Based Logic}: Efficient non\sphinxhyphen{}blocking movement calculations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Event\sphinxhyphen{}Driven Updates}: Animation updates only when needed

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Modular Design}: Clean separation of movement, animation, and interaction systems

\end{itemize}


\subsection{Integration with Mixed Mobility Simulation}
\label{\detokenize{Human Agent:integration-with-mixed-mobility-simulation}}

\subsubsection{Bicycle Interaction}
\label{\detokenize{Human Agent:bicycle-interaction}}
\sphinxAtStartPar
Human agents serve as dynamic obstacles for bicycle navigation:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Detected by bicycle sphere casting on “Humans” layer

\item {} 
\sphinxAtStartPar
Create realistic pedestrian\sphinxhyphen{}cyclist interaction scenarios

\item {} 
\sphinxAtStartPar
Enable study of mixed traffic dynamics

\end{itemize}

\sphinxstepscope


\chapter{The Simulation}
\label{\detokenize{The Simulation:the-simulation}}\label{\detokenize{The Simulation::doc}}
\sphinxAtStartPar
The active mobility simulation provides an interactive environment for studying and analyzing the movement patterns of pedestrians and cyclists in urban settings. The simulation combines realistic 3D environments with configurable agent behaviors to create scenarios that mirror real\sphinxhyphen{}world active mobility situations.


\section{Simulation Overview}
\label{\detokenize{The Simulation:simulation-overview}}
\sphinxAtStartPar
The simulation is built as an interactive Unity application that allows users to place, configure, and observe different types of mobility agents within a realistic urban environment. The system leverages Unity’s NavMesh navigation system to provide intelligent pathfinding and movement behaviors for all agents in the scene.


\section{Agent Placement and Selection}
\label{\detokenize{The Simulation:agent-placement-and-selection}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{simulation}.png}
\caption{The main simulation interface showing agent placement options}\label{\detokenize{The Simulation:simulation-interface}}\end{figure}


\subsection{Initial Setup Phase}
\label{\detokenize{The Simulation:initial-setup-phase}}
\sphinxAtStartPar
When the simulation loads, users are presented with a clean urban environment featuring a university campus setting. The interface provides two primary agent placement options:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Human Agent Placement}: Allows users to place pedestrian agents throughout the scene

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Bicycle Agent Placement}: Enables placement of cyclist agents at desired locations

\end{itemize}

\sphinxAtStartPar
To place an agent in the scene:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Select either the human or bicycle button from the placement interface

\item {} 
\sphinxAtStartPar
Click on any accessible location within the 3D environment

\item {} 
\sphinxAtStartPar
The selected agent type will be instantiated at the clicked position

\item {} 
\sphinxAtStartPar
Multiple agents of each type can be placed as needed

\end{enumerate}


\subsection{Agent Configuration}
\label{\detokenize{The Simulation:agent-configuration}}
\sphinxAtStartPar
Once an agent is placed in the scene, clicking on it reveals a configuration panel specific to that agent type. Each agent can be individually customized with the following parameters:


\subsubsection{Human Agent Options}
\label{\detokenize{The Simulation:human-agent-options}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{humanoptions}.png}
\caption{Configuration panel for human agent parameters}\label{\detokenize{The Simulation:human-options-panel}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Speed}: Controls the walking pace of the pedestrian (units per second)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Angular Speed}: Determines how quickly the agent can change direction (degrees per second)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Acceleration}: Sets how rapidly the agent reaches target speed

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stop Distance}: Defines how close the agent gets to its destination before stopping

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Brake}: Toggle for automatic deceleration when approaching destinations

\end{itemize}


\subsubsection{Bicycle Agent Options}
\label{\detokenize{The Simulation:bicycle-agent-options}}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{bicycle_options}.png}
\caption{Configuration panel for bicycle agent parameters}\label{\detokenize{The Simulation:bicycle-options-panel}}\end{figure}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Speed}: Sets the cycling speed of the bicycle agent (units per second)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Angular Speed}: Controls turning speed and maneuverability (degrees per second)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Acceleration}: Determines how quickly the bicycle reaches target speed

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Stop Distance}: Sets the stopping distance from target destinations

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Auto Brake}: Automatic braking behavior when approaching stops

\end{itemize}

\sphinxAtStartPar
These configuration options allow for realistic differentiation between agent types, with bicycles typically configured for higher speeds and different turning characteristics compared to pedestrians.


\section{Simulation Execution}
\label{\detokenize{The Simulation:simulation-execution}}

\subsection{Starting the Simulation}
\label{\detokenize{The Simulation:starting-the-simulation}}
\sphinxAtStartPar
Once all desired agents have been placed and configured, the simulation can be initiated by clicking the “Start Simulation” button. This action triggers several important changes:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{UI Transition}: The placement and configuration interface disappears, providing an unobstructed view of the simulation environment

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Agent Activation}: All placed agents begin their navigation behaviors according to their configured parameters

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pathfinding Initialization}: Agents start calculating and following optimal paths through the environment

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Interactive Mode}: The simulation enters its active phase where real\sphinxhyphen{}time observation and interaction are possible

\end{enumerate}


\subsection{Runtime Behavior}
\label{\detokenize{The Simulation:runtime-behavior}}
\sphinxAtStartPar
During simulation execution, agents demonstrate intelligent navigation behaviors:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Pathfinding}: Agents automatically calculate routes to their destinations using the underlying NavMesh

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Obstacle Avoidance}: Dynamic collision avoidance between different agent types

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Realistic Movement}: Speed and acceleration parameters create natural\sphinxhyphen{}looking movement patterns

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Environmental Interaction}: Agents navigate around static obstacles and terrain features

\end{itemize}


\section{Interactive Camera System}
\label{\detokenize{The Simulation:interactive-camera-system}}

\subsection{Free Camera Movement}
\label{\detokenize{The Simulation:free-camera-movement}}
\sphinxAtStartPar
While the simulation runs, users can freely navigate through the 3D environment to observe agent behaviors from different perspectives. The camera system provides:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Position Control}: Move through the scene to focus on specific areas of interest

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Rotation Control}: Adjust viewing angles to observe interactions and movement patterns

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Zoom Capabilities}: Get close\sphinxhyphen{}up views of individual agents or wide shots of group behaviors

\end{itemize}


\subsection{Agent\sphinxhyphen{}Specific Views}
\label{\detokenize{The Simulation:agent-specific-views}}
\sphinxAtStartPar
A key feature of the simulation is the ability to switch to first\sphinxhyphen{}person perspectives of individual agents:

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{human_view}.png}
\caption{First\sphinxhyphen{}person perspective from a human agent showing the campus environment}\label{\detokenize{The Simulation:human-agent-first-person-view}}\end{figure}

\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{bicycle_view}.png}
\caption{First\sphinxhyphen{}person perspective from a bicycle agent navigating through the simulation}\label{\detokenize{The Simulation:bicycle-agent-first-person-view}}\end{figure}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Agent Selection}: Click on any human or bicycle agent during simulation runtime

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{View Transition}: The camera automatically switches to that agent’s perspective

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Agent Experience}: Experience the simulation from the viewpoint of the selected agent

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{Immersive Observation}: Understand movement patterns and environmental interactions from the agent’s perspective

\end{enumerate}

\sphinxAtStartPar
This feature provides valuable insights into:
\begin{itemize}
\item {} 
\sphinxAtStartPar
How different agent types perceive and navigate the environment

\item {} 
\sphinxAtStartPar
The effectiveness of pathfinding algorithms from an agent’s viewpoint

\item {} 
\sphinxAtStartPar
Spatial relationships and proximity interactions between agents

\item {} 
\sphinxAtStartPar
Environmental factors that influence navigation decisions

\end{itemize}

\sphinxstepscope


\chapter{Glossary}
\label{\detokenize{glossary:glossary}}\label{\detokenize{glossary::doc}}

\section{Active mobility}
\label{\detokenize{glossary:active-mobility}}
\sphinxAtStartPar
The transport of people or goods, through non\sphinxhyphen{}motorized means, based around human physical activity.


\section{Mesh}
\label{\detokenize{glossary:mesh}}
\sphinxAtStartPar
The foundational element of a 3D object, a collection of vertices (points), edges (lines connecting vertices), and faces (flat surfaces enclosed by edges) that defines an object’s shape.


\section{Armature}
\label{\detokenize{glossary:armature}}
\sphinxAtStartPar
An object that serves as a skeleton for rigging and animating other objects, allowing complex deformations to be controlled through a hierarchy of individual bones.


\section{Bone}
\label{\detokenize{glossary:bone}}
\sphinxAtStartPar
A basic element of an armature, a skeletal structure used for rigging and animating characters and objects.

\sphinxstepscope


\chapter{Conclusion}
\label{\detokenize{Conclusion:conclusion}}\label{\detokenize{Conclusion::doc}}
\sphinxAtStartPar
In conclusion, the application is currently in a state where it can accurately depict the data presented to it and can apply, as well as create, simple case studies of active movement in a specific built environment which can help experts with their research and the display of said research. As there are a lot of tools on this topic this one is a lot more accessible for the simple reason that it is something to show the research as much as conduct it. As for the future of this application, the few things that could be added are other vehicles like cars, a way to change the location easily, and a more sophisticated way to change the behavior of the pedestrians.

\sphinxstepscope


\chapter{Bibliography}
\label{\detokenize{bibliography:bibliography}}\label{\detokenize{bibliography::doc}}\phantomsection\label{\detokenize{bibliography:id1}}






\renewcommand{\indexname}{Index}
\printindex
\end{document}